package ca.csf.mobile2.tp2.question

import android.annotation.SuppressLint
import android.app.Activity
import android.content.Intent
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import ca.csf.mobile2.tp2.R
import ca.csf.mobile2.tp2.databinding.ActivityAskQuestionBinding
import ca.csf.mobile2.tp2.question.viewModels.AskQuestionActivityViewModel
import com.google.android.material.snackbar.Snackbar
import kotlinx.android.synthetic.main.activity_ask_question.*
import okhttp3.ResponseBody
import org.androidannotations.annotations.*
import java.util.*

@SuppressLint("Registered") //Reason : Generated by Android Annotations
@DataBound
@OptionsMenu(R.menu.activity_ask_question)
@EActivity(R.layout.activity_ask_question)
class AskQuestionActivity : AppCompatActivity() {

    @BindingObject
    protected lateinit var binding: ActivityAskQuestionBinding

    @InstanceState
    protected lateinit var viewModel: AskQuestionActivityViewModel

    @InstanceState
    protected lateinit var questionData: QuestionData

    @ViewById(R.id.toolbar)
    protected lateinit var toolbar: Toolbar

    @Bean
    protected lateinit var questionService: QuestionService

    @AfterViews
    protected fun onCreate() {
        initView()
        if (!this::viewModel.isInitialized) {
            questionData = QuestionData()
            viewModel = AskQuestionActivityViewModel(questionData)
            findRandomQuestion()
        }
        binding.viewModel = viewModel
    }

    private fun initView() {
        setSupportActionBar(toolbar)
    }

    @Click(R.id.choice1Button)
    protected fun sendChoice1() {
        //BC : Il es possible de "spam" ce bouton pendant le loading.
        questionService.choose1(
            questionData,
            this::onSuccess,
            this::onServerError,
            this::onConnectivityError
        )
        viewModel.isLoading = true
    }

    @Click(R.id.choice2Button)
    protected fun sendChoice2() {
        //BC : Il es possible de "spam" ce bouton pendant le loading.
        questionService.choose2(
            questionData,
            this::onSuccess,
            this::onServerError,
            this::onConnectivityError
        )
        viewModel.isLoading = true
    }

    @Click(R.id.createButton)
    protected fun onClickCreateButton() {
        startActivityForResult(
            Intent(this, CreateQuestionActivity_::class.java),
            CREATE_QUESTION_REQUEST_CODE
        )
    }

    @Click(R.id.retryButton, R.id.choice1ResultBackground, R.id.choice2ResultBackground)
    protected fun findRandomQuestion() {
        questionService.findRandomQuestion(
            this::onSuccess,
            this::onServerError,
            this::onConnectivityError
        )
        viewModel.isLoading = true
    }

    @OptionsItem(R.id.flagButton)
    protected fun flagQuestion() {
        questionService.flagQuestion(
            questionData,
            this::onSuccess,
            this::onServerError,
            this::onConnectivityError
        )
        //BC : Bogue. Aucune loading visible.
    }

    private fun findQuestion(id : UUID){
        questionService.findQuestionById(
            id,
            this::onSuccess,
            this::onServerError,
            this::onConnectivityError
        )
        //BC : Bogue. Aucune loading visible.
    }

    private fun onSuccess(question: QuestionData) {
        questionData = question
        viewModel.isLoading = false
        viewModel.questionData = question

        //BC : TRÈS fragile. Surtour si on "spam" le bouton pour soumettre une question.
        if (!viewModel.isAskingQuestion) {
            viewModel.isAskingQuestion = true
        } else {
            viewModel.isQuestionAnswered = true
        }
    }

    //Pour le flag qui a une réponse différente.
    private fun onSuccess(response: ResponseBody) {
        viewModel.isFlagging = true

        if (response.string() == FLAG_RESPONSE_OK) {
            Snackbar.make(rootView, R.string.text_reported, Snackbar.LENGTH_LONG).show()
        } else {
            Snackbar.make(rootView, R.string.text_reported_deleted, Snackbar.LENGTH_LONG).show()
        }
        findRandomQuestion()
    }

    private fun onServerError() {
        viewModel.isLoading = false
        viewModel.isErrorDetected = true
    }

    private fun onConnectivityError() {
        viewModel.isLoading = false
        viewModel.isErrorDetected = true
        viewModel.isConnectivityErrorDetected = true
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        if (resultCode == Activity.RESULT_OK && requestCode == CREATE_QUESTION_REQUEST_CODE) {
            //isAskingQuestion = false nécessaire pour ne pas afficher les résultat de la question dans le onSuccess.
            viewModel.isAskingQuestion = false
            val id: UUID = data!!.getSerializableExtra(EXTRA_NAME) as UUID
            findQuestion(id)
        }
    }
}

private const val FLAG_RESPONSE_OK = "OK"
private const val CREATE_QUESTION_REQUEST_CODE = 1
//BC : Cette constante est à deux places différentes.
private const val EXTRA_NAME = "QUESTION"
